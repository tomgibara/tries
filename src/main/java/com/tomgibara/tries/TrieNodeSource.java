package com.tomgibara.tries;

import com.tomgibara.streams.StreamDeserializer;

/**
 * <p>
 * A source of {@link TrieNodes}. Sources are supplied to {@link Tries} via the
 * {@link Tries#nodeSource(TrieNodeSource)} method to control how nodes are
 * managed for {@link Trie} instances it creates.
 * 
 * <p>
 * The interface also defines a number of 'standard' implementations that are
 * optimized for different scenarios. Other than their convenient availability
 * as part of this package, they are not distinguished from alternatively
 * defined sources that may better suite some applications.
 * 
 * @author Tom Gibara
 * @see TrieNodes
 * @see Tries
 */

public interface TrieNodeSource  {

	/**
	 * Models trie nodes using a Java object for each node; this is fast, at
	// the expense of a larger memory overhead than other implementations.
	 * 
	 * @return a source that provides generally good performance.
	 */

	static TrieNodeSource forSpeed() {
		return BasicTrieNodes.SOURCE;
	}
	
	/**
	 * Models trie nodes using integers to reduce the memory overhead associated
	 * with Java objects. To further reduce memory overhead there is additional
	 * logic to byte-pack non-branching child sequences. This implementation
	 * typically operates approximately half as fast as {@link #forSpeed()}
	 * 
	 * @return a source that stores reduces memory overhead
	 */

	static TrieNodeSource forCompactness() {
		return PackedTrieNodes.SOURCE;
	}

	/**
	 * Models trie nodes simiilarly to {@link #forCompactness()} with further
	 * logic that linearizes siblings during compaction to enable binary
	 * searches over successor nodes. This typically doubles the speed of
	 * lookups over the {@link #forCompactness()} implementation at the expense
	 * of doubling the time for removals.
	 * 
	 * @return a source that facilitates faster lookups over a compact memory
	 *         representation
	 */

	static TrieNodeSource forCompactLookups() {
		return CompactTrieNodes.SOURCE;
	}
	
	/**
	 * Creates a new empty node structure.
	 * 
	 * @param byteOrder
	 *            the ordering to be applied to a node's direct descendants
	 * @param counting
	 *            whether the nodes are expected to provide efficient descendent
	 *            counts
	 * @param capacityHint
	 *            hints at the number of nodes the trie may grow to contain
	 * @return an empty tree of nodes
	 */

	TrieNodes newNodes(ByteOrder byteOrder, boolean counting, int capacityHint);
	
	/**
	 * Copies the nodes from an existing {@link TrieNodes} instance. The byte
	 * order on the supplied nodes determines the byte order of the returned
	 * nodes. The implementation of this method cannot generally assume that the
	 * nodes passed in originate from the same {@link TrieNodeSource}.
	 * 
	 * @param nodes
	 *            the nodes to duplicate
	 * @param counting
	 *            whether the duplicated nodes are expected to provide efficient
	 *            descendent counts
	 * @param capacityHint
	 *            hints at the number of nodes the trie may grow to contain
	 * @return a copy of the supplied nodes
	 */
	
	TrieNodes copyNodes(TrieNodes nodes, boolean counting, int capacityHint);

	/**
	 * Provides an object that can deserialize the data generated by
	 * {@link TrieNode#writeNodes(com.tomgibara.streams.WriteStream)} into a new
	 * tree.
	 * 
	 * @param byteOrder
	 *            the byte order that was applied to the serialization
	 * @param counting
	 *            whether the reconstructed nodes are expected to provide
	 *            efficient descendent counts
	 * @param capacityHint
	 *            hints at the number of nodes the trie may grow to contain
	 * @return a tree of nodes restored from a byte stream
	 */

	StreamDeserializer<TrieNodes> deserializer(ByteOrder byteOrder, boolean counting, int capacityHint);
}
